<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="../util.js"></script>
<style>
    math {
        font-size: 3em;
        display: none;
    }
</style>
<math>
    <msub>
        <mi>x</mi>
        <mrow>
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
        </mrow>
    </msub>
    <mo>=</mo>
    <mi>a</mi>
    <msub>
        <mi>x</mi>
        <mi>n</mi>
    </msub>
    <mo>+</mo>
    <mi>b</mi>
    <msub>
        <mi>y</mi>
        <mi>n</mi>
    </msub>
    <mo>+</mo>
    <mi>e</mi>
</math>
<math>
    <msub>
        <mi>y</mi>
        <mrow>
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
        </mrow>
    </msub>
    <mo>=</mo>
    <mi>c</mi>
    <msub>
        <mi>y</mi>
        <mi>n</mi>
    </msub>
    <mo>+</mo>
    <mi>d</mi>
    <msub>
        <mi>y</mi>
        <mi>n</mi>
    </msub>
    <mo>+</mo>
    <mi>f</mi>
</math>
<script>
    class IFS {
        constructor(coes, probs) {
            if (coes[0].length !== 6) throw Error('A coefficients array must contain 6 elements.')
            this.coes = coes
            if (probs) {
                if (coes.length !== probs.length) throw Error('Coefficients array and probablilities array is not the same length')
                this.probs = probs
            } else {
                this.probs = Array.from(coes, () => 1 / coes.length)
            }
        }
        update(x, y) {
            const r = Math.random()
            let idx = 0
            for (let prob = 0; r > (prob += this.probs[idx]); ++idx);
            const [a, b, c, d, e, f] = this.coes[idx]
            const nx = a * x + b * y + e
            const ny = c * x + d * y + f
            return [nx, ny]
        }
    }

    const barnsleysFernIfs = new IFS(
        [
            [0, 0, 0, 0.16, 0, 0],
            [0.85, 0.04, -0.04, 0.85, 0, 1.60],
            [0.20, -0.26, 0.23, 0.22, 0, 1.60],
            [-0.15, 0.28, 0.26, 0.24, 0, 0.44]
        ],
        [0.01, 0.85, 0.07, 0.07]
    )

    const mapleLeafIfs = new IFS([
        [0.1400,  0.0100,  0.0000, 0.5100, -0.0800, -1.3100],
        [0.4300,  0.5200, -0.4500, 0.5000,  1.4900, -0.7500],
        [0.4500, -0.4900,  0.4700, 0.4700, -1.6200, -0.7400],
        [0.4900,  0.0000,  0.0000, 0.5100,  0.0200,  1.6200],
    ])

    const randomIFS = new IFS(Array.from({ length: 4 }, () => genSet()))

    function genSet() {
        const m = Math.random() * Math.PI * 2
        const n = Math.random() * Math.PI * 2
        const ra = Math.random()
        const rb = Math.random()

        const a = Math.sin(m) * ra
        const b = Math.cos(m) * ra
        const c = Math.sin(n) * rb
        const d = Math.cos(n) * rb
        const e = Math.random() * 2 - 1
        const f = Math.random() * 2 - 1

        return [a, b, c, d, e, f]
    }

    const ctx = ce('canvas')
        .$attr({ width: 800, height: 800 })
        .$style({ border: 'solid currentcolor', float: 'left' })
        .getContext('2d')

    const arr = Array(100000) // x, y coordinates
    const counts = Array(ctx.canvas.width * ctx.canvas.height)

    onload = main

    // global variables
    const draw = drawPixels
    let group
    let ifs = mapleLeafIfs

    function main() {
        function change(nifs, sliders) {
            ifs = nifs
            group.replaceWith(sliders)
            group = sliders
            draw()
        }
        const slider1 = setSliders(mapleLeafIfs)
        const slider2 = setSliders(barnsleysFernIfs)
        const slider3 = setSliders(randomIFS)
        const switcher = ce('div',
            ce('button', 'Mapleleafe').$attr({ onclick: () => change(mapleLeafIfs, slider1) }),
            ce('button', "Barnsley's Fern").$attr({ onclick: () => change(barnsleysFernIfs, slider2) }),
            ce('button', 'random').$attr({ onclick: () => change(randomIFS, slider3) }),
        )
        group = slider1
        document.body.append(switcher, ctx.canvas, group)

        // setup sliders
        if (draw === drawPoints) {
            group = new SliderGroup
            group.attr = { oninput: draw }
            group.add('scale', { value: 70 })
            group.add('iteration', { min: 100, max: 30000, value: 13000 })
            document.body.append(group.container)
        }

        draw()
    }

    function map(n, a, b, x, y) { return x + (n - a) / (b - a) * (y - x) }

    function drawPixels() {
        let x = 0, y = 0
        let min = max = 0
        for (let i = 0; i < arr.length; i += 2) {
            [x, y] = ifs.update(x, y)
            min = Math.min(min, x, y)
            max = Math.max(max, x, y)
            arr[i]     = x
            arr[i + 1] = y
        }

        counts.fill(0)
        let maxCount = 0
        for (let i = 0; i < arr.length; i += 2) {
            const x = Math.floor(map(arr[  i  ], min, max, 0, ctx.canvas.width - 1))
            const y = Math.floor(map(arr[i + 1], min, max, 0, ctx.canvas.height - 1))
            const idx = x + ctx.canvas.width * y
            maxCount = Math.max(++counts[idx], maxCount)
        }

        const pixels = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
        for (let x = 0; x < ctx.canvas.width; ++x) {
            for (let y = 0; y < ctx.canvas.height; ++y) {
                const i = x + y * ctx.canvas.width
                const bri = Math.log1p(counts[i]) / Math.log1p(maxCount) * 255 | 0
                pixels.data[i * 4]     = 0
                pixels.data[i * 4 + 1] = 0
                pixels.data[i * 4 + 2] = 0
                pixels.data[i * 4 + 3] = bri
            }
        }
        ctx.putImageData(pixels, 0, 0)
    }

    function drawPoints() {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
        ctx.save()

        {
            ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2)
            ctx.scale(1, -1)

            const scale = group.value('scale')
            const iteration = group.value('iteration')

            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'
            let x = 0, y = 0
            for (let i = 0; i < iteration; ++i) {
                [x, y] = ifs.update(x, y)
                ctx.fillRect(x * scale, y * scale, 1, 1)
            }
        }

        ctx.restore()
    }

    function setSliders(ifs) {
        const names = ['a', 'b', 'c', 'd', 'e', 'f']
        const buttons = ce('div')
        const ele = ce('div', 'Parameter sets', buttons).$style({
            border: 'solid currentcolor',
            'max-width': 'max-content',
            padding: '1rem',
            float: 'left'
        })
        let currentSet
        for (let j = 0; j < ifs.coes.length; ++j) {
            const set = ifs.coes[j]
            const group = new SliderGroup
            group.attr = { min: -2, max: 2, step: 0.01 }
            group.container.append(`Set ${j}`, ce('br'))
            if (j === 0) {
                currentSet = group.container
                ele.append(currentSet)
            }
            buttons.append(ce('button', `Set ${j}`).$attr({ onclick: function() {
                currentSet.replaceWith(group.container)
                currentSet = group.container
            } }))
            for (let i = 0; i < 4; ++i)
                group.add(names[i], { value: set[i], oninput: function() { set[i] = this.value; draw() } })
        }

        return ele
    }
</script>